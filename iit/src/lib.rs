//! # Integrated Information Theory (IIT) 3.0 Library
//!
//! This library provides a complete implementation of Integrated Information Theory (IIT) 3.0,
//! a mathematical framework for understanding consciousness and integrated information.
//!
//! ## Overview
//!
//! IIT quantifies consciousness as integrated information (Φ, phi) - the amount of information
//! generated by a system above and beyond the information generated by its parts. The theory
//! provides rigorous mathematical tools for analyzing neural and computational systems.
//!
//! ## Key Concepts
//!
//! - **Φ (Phi)**: Integrated information, measuring irreducibility to parts
//! - **Concepts**: Mechanisms with irreducible cause-effect power
//! - **Cause-Effect Structure**: The constellation of all concepts in a system
//! - **MIP (Minimum Information Partition)**: The partition minimizing integration
//! - **MICE**: Maximally Irreducible Cause-Effect for a mechanism
//!
//! ## Quick Start
//!
//! ```rust
//! use iit::{IITSystem, PhiConfig, ApproximationMethod};
//! use ndarray::Array;
//!
//! // Create a simple 3-neuron system
//! let mut system = IITSystem::new(3);
//!
//! // Set up connectivity (all-to-all)
//! for i in 0..3 {
//!     for j in 0..3 {
//!         if i != j {
//!             system.set_connection(i, j, true);
//!         }
//!     }
//! }
//!
//! // Set system state
//! system.set_state(vec![1, 0, 1]).unwrap();
//!
//! // Calculate Φ
//! let result = system.calculate_phi().unwrap();
//! println!("Φ = {}", result.phi);
//! ```
//!
//! ## Modules
//!
//! - [`phi`]: Φ calculation with multiple approximation methods
//! - [`partition`]: Partition enumeration and MIP search
//! - [`repertoire`]: Cause and effect repertoire computation
//! - [`causality`]: Cause-effect structure analysis
//! - [`concepts`]: Concept identification
//! - [`emd`]: Earth Mover's Distance for comparing distributions
//! - [`error`]: Error types
//!
//! ## Theory Background
//!
//! IIT 3.0 (Oizumi, Albantakis, & Tononi, 2014) builds on earlier versions to provide
//! a complete mathematical framework. Key publications:
//!
//! - Tononi, G. (2004). An information integration theory of consciousness.
//! - Balduzzi, D., & Tononi, G. (2008). Integrated information in discrete dynamical systems.
//! - Oizumi, M., Albantakis, L., & Tononi, G. (2014). From the phenomenology to the
//!   mechanisms of consciousness: Integrated Information Theory 3.0.
//!
//! ## Performance
//!
//! - **Exact calculation**: Up to ~15 elements (exponential complexity)
//! - **Geometric approximation**: Fast, good for qualitative analysis
//! - **Spectral approximation**: Based on eigenvalue decomposition
//! - **Mean field approximation**: For large systems (>100 elements)
//! - **Parallel computation**: Enabled by default using rayon

pub mod causality;
pub mod concepts;
pub mod emd;
pub mod error;
pub mod partition;
pub mod phi;
pub mod repertoire;

// Re-export main types
pub use causality::{CauseEffect, MIC, MIE, MICE};
pub use concepts::{CauseEffectStructure, Concept, ConceptConfig, QualiaSpace};
pub use emd::{earth_movers_distance, kl_divergence, l1_distance};
pub use error::{IITError, Result};
pub use partition::{CutType, Partition, PartitionInfo};
pub use phi::{ApproximationMethod, PhiConfig, PhiResult};
pub use repertoire::{Direction, Repertoire};

use ndarray::{Array, ArrayD, IxDyn};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};

/// The main IIT system structure.
///
/// This represents a neural or computational system for which integrated information
/// can be calculated.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IITSystem {
    /// Number of elements in the system.
    n_elements: usize,
    /// Current state of the system.
    state: Vec<usize>,
    /// Transition Probability Matrix (TPM).
    /// Shape: [2, 2, ..., 2, 2, ..., 2] (2*n_elements dimensions)
    tpm: ArrayD<f64>,
    /// Connectivity matrix (n x n).
    connectivity: Vec<Vec<bool>>,
    /// Configuration for Φ calculation.
    config: PhiConfig,
}

impl IITSystem {
    /// Create a new IIT system with n elements.
    ///
    /// # Arguments
    ///
    /// * `n_elements` - Number of elements in the system
    ///
    /// # Example
    ///
    /// ```
    /// use iit::IITSystem;
    ///
    /// let system = IITSystem::new(3);
    /// ```
    pub fn new(n_elements: usize) -> Self {
        // Initialize with default state (all zeros)
        let state = vec![0; n_elements];

        // Initialize TPM with uniform probabilities
        let shape: Vec<_> = (0..2 * n_elements).map(|_| 2).collect();
        let tpm = Array::from_elem(IxDyn(&shape), 0.5);

        // Initialize with no connections
        let connectivity = vec![vec![false; n_elements]; n_elements];

        Self {
            n_elements,
            state,
            tpm,
            connectivity,
            config: PhiConfig::default(),
        }
    }

    /// Create a new system with custom configuration.
    pub fn with_config(n_elements: usize, config: PhiConfig) -> Self {
        let mut system = Self::new(n_elements);
        system.config = config;
        system
    }

    /// Get the number of elements.
    pub fn n_elements(&self) -> usize {
        self.n_elements
    }

    /// Set the system state.
    pub fn set_state(&mut self, state: Vec<usize>) -> Result<()> {
        if state.len() != self.n_elements {
            return Err(IITError::dimension_mismatch(self.n_elements, state.len()));
        }

        // Validate state (should be binary)
        if state.iter().any(|&s| s > 1) {
            return Err(IITError::invalid_state("State must be binary (0 or 1)"));
        }

        self.state = state;
        Ok(())
    }

    /// Get the current state.
    pub fn state(&self) -> &[usize] {
        &self.state
    }

    /// Set a connection between two elements.
    pub fn set_connection(&mut self, from: usize, to: usize, connected: bool) -> Result<()> {
        if from >= self.n_elements || to >= self.n_elements {
            return Err(IITError::InvalidConnectivity(format!(
                "Invalid indices: from={}, to={}, n={}",
                from, to, self.n_elements
            )));
        }

        self.connectivity[from][to] = connected;
        Ok(())
    }

    /// Get the connectivity matrix.
    pub fn connectivity(&self) -> &[Vec<bool>] {
        &self.connectivity
    }

    /// Set the full connectivity matrix.
    pub fn set_connectivity(&mut self, connectivity: Vec<Vec<bool>>) -> Result<()> {
        if connectivity.len() != self.n_elements {
            return Err(IITError::invalid_connectivity("Wrong number of rows"));
        }

        for row in &connectivity {
            if row.len() != self.n_elements {
                return Err(IITError::invalid_connectivity("Wrong number of columns"));
            }
        }

        self.connectivity = connectivity;
        Ok(())
    }

    /// Set the Transition Probability Matrix.
    pub fn set_tpm(&mut self, tpm: ArrayD<f64>) -> Result<()> {
        // Validate dimensions
        let expected_dims = 2 * self.n_elements;
        if tpm.ndim() != expected_dims {
            return Err(IITError::InvalidTPM(format!(
                "Expected {} dimensions, got {}",
                expected_dims,
                tpm.ndim()
            )));
        }

        // Validate probabilities
        if tpm.iter().any(|&p| p < 0.0 || p > 1.0) {
            return Err(IITError::InvalidTPM(
                "TPM contains invalid probabilities".to_string(),
            ));
        }

        self.tpm = tpm;
        Ok(())
    }

    /// Get the TPM.
    pub fn tpm(&self) -> &ArrayD<f64> {
        &self.tpm
    }

    /// Set the configuration.
    pub fn set_config(&mut self, config: PhiConfig) {
        self.config = config;
    }

    /// Get the configuration.
    pub fn config(&self) -> &PhiConfig {
        &self.config
    }

    /// Calculate Φ for the system in its current state.
    pub fn calculate_phi(&self) -> Result<PhiResult> {
        phi::calculate_phi(&self.state, &self.tpm, &self.connectivity, &self.config)
    }

    /// Identify all concepts in the system.
    pub fn identify_concepts(&self) -> Result<CauseEffectStructure> {
        let concept_config = ConceptConfig {
            min_phi: 0.0,
            max_mechanism_size: None,
            parallel: self.config.parallel,
        };

        concepts::identify_concepts(&self.state, &self.tpm, &self.connectivity, &concept_config)
    }

    /// Identify concepts with custom configuration.
    pub fn identify_concepts_with_config(
        &self,
        concept_config: &ConceptConfig,
    ) -> Result<CauseEffectStructure> {
        concepts::identify_concepts(&self.state, &self.tpm, &self.connectivity, concept_config)
    }

    /// Analyze the full causal structure.
    pub fn analyze_causal_structure(&self) -> Result<Vec<MICE>> {
        causality::analyze_causal_structure(&self.state, &self.tpm, &self.connectivity)
    }

    /// Calculate Φ for all mechanisms.
    pub fn calculate_phi_all_mechanisms(&self) -> Result<Vec<(Vec<usize>, PhiResult)>> {
        phi::calculate_phi_all_mechanisms(&self.state, &self.tpm, &self.connectivity, &self.config)
    }

    /// Get the qualia space analysis.
    pub fn analyze_qualia_space(&self) -> Result<QualiaSpace> {
        let ces = self.identify_concepts()?;
        Ok(concepts::analyze_qualia_space(&ces))
    }
}

/// Builder for creating IIT systems with fluent API.
pub struct IITSystemBuilder {
    n_elements: usize,
    state: Option<Vec<usize>>,
    connectivity: Option<Vec<Vec<bool>>>,
    tpm: Option<ArrayD<f64>>,
    config: PhiConfig,
}

impl IITSystemBuilder {
    /// Create a new builder.
    pub fn new(n_elements: usize) -> Self {
        Self {
            n_elements,
            state: None,
            connectivity: None,
            tpm: None,
            config: PhiConfig::default(),
        }
    }

    /// Set the initial state.
    pub fn state(mut self, state: Vec<usize>) -> Self {
        self.state = Some(state);
        self
    }

    /// Set the connectivity matrix.
    pub fn connectivity(mut self, connectivity: Vec<Vec<bool>>) -> Self {
        self.connectivity = Some(connectivity);
        self
    }

    /// Set all-to-all connectivity.
    pub fn fully_connected(mut self) -> Self {
        let mut conn = vec![vec![true; self.n_elements]; self.n_elements];
        for i in 0..self.n_elements {
            conn[i][i] = false; // No self-connections
        }
        self.connectivity = Some(conn);
        self
    }

    /// Set the TPM.
    pub fn tpm(mut self, tpm: ArrayD<f64>) -> Self {
        self.tpm = Some(tpm);
        self
    }

    /// Set the configuration.
    pub fn config(mut self, config: PhiConfig) -> Self {
        self.config = config;
        self
    }

    /// Set approximation method.
    pub fn approximation(mut self, method: ApproximationMethod) -> Self {
        self.config.approximation = method;
        self
    }

    /// Enable or disable parallel computation.
    pub fn parallel(mut self, parallel: bool) -> Self {
        self.config.parallel = parallel;
        self
    }

    /// Build the system.
    pub fn build(self) -> Result<IITSystem> {
        let mut system = IITSystem::with_config(self.n_elements, self.config);

        if let Some(state) = self.state {
            system.set_state(state)?;
        }

        if let Some(connectivity) = self.connectivity {
            system.set_connectivity(connectivity)?;
        }

        if let Some(tpm) = self.tpm {
            system.set_tpm(tpm)?;
        }

        Ok(system)
    }
}

/// Helper function to create a fully connected system.
pub fn fully_connected_system(n_elements: usize) -> IITSystem {
    IITSystemBuilder::new(n_elements)
        .fully_connected()
        .build()
        .unwrap()
}

/// Helper function to create a simple feedforward system.
pub fn feedforward_system(n_elements: usize) -> IITSystem {
    let mut system = IITSystem::new(n_elements);

    // Connect each element to the next
    for i in 0..n_elements - 1 {
        system.set_connection(i, i + 1, true).unwrap();
    }

    system
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_system() {
        let system = IITSystem::new(3);
        assert_eq!(system.n_elements(), 3);
        assert_eq!(system.state(), &[0, 0, 0]);
    }

    #[test]
    fn test_set_state() {
        let mut system = IITSystem::new(3);
        system.set_state(vec![1, 0, 1]).unwrap();
        assert_eq!(system.state(), &[1, 0, 1]);
    }

    #[test]
    fn test_invalid_state() {
        let mut system = IITSystem::new(3);
        let result = system.set_state(vec![1, 2, 0]);
        assert!(result.is_err());
    }

    #[test]
    fn test_set_connection() {
        let mut system = IITSystem::new(3);
        system.set_connection(0, 1, true).unwrap();
        assert!(system.connectivity()[0][1]);
    }

    #[test]
    fn test_builder() {
        let system = IITSystemBuilder::new(3)
            .state(vec![1, 0, 1])
            .fully_connected()
            .approximation(ApproximationMethod::Geometric)
            .build()
            .unwrap();

        assert_eq!(system.n_elements(), 3);
        assert_eq!(system.state(), &[1, 0, 1]);
        assert_eq!(
            system.config().approximation,
            ApproximationMethod::Geometric
        );
    }

    #[test]
    fn test_fully_connected_system() {
        let system = fully_connected_system(4);

        // Should have connections between all distinct pairs
        for i in 0..4 {
            for j in 0..4 {
                if i != j {
                    assert!(system.connectivity()[i][j]);
                } else {
                    assert!(!system.connectivity()[i][j]);
                }
            }
        }
    }

    #[test]
    fn test_feedforward_system() {
        let system = feedforward_system(4);

        // Should have connections 0->1, 1->2, 2->3
        for i in 0..3 {
            assert!(system.connectivity()[i][i + 1]);
        }
    }

    #[test]
    fn test_calculate_phi() {
        let mut system = IITSystem::new(2);
        system.set_state(vec![1, 0]).unwrap();

        let result = system.calculate_phi().unwrap();
        assert!(result.phi >= 0.0);
    }
}
